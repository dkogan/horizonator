# data file for the Fltk User Interface Designer (fluid)
version 1.0110 
header_name {.h} 
code_name {.cxx}
decl {\#include <cstring>} {global
} 

decl {\#include <iostream>} {global
} 

decl {\#include <sstream>} {global
} 

decl {\#include "orb_ui.hpp"} {global
} 

decl {\#include "orb_osmlayer.hpp"} {global
} 

decl {\#include "orb_gpxlayer.hpp"} {global
} 

decl {\#include "orb_mapctrl.hpp"} {public global
} 

decl {\#include "orb_layers.hpp"} {public global
} 

decl {\#include "orb_about.hpp"} {public global
} 

decl {\#include "orb_dlg_settings.hpp"} {public global
} 

class orb_ui {open
} {
  decl {orb_layers *m_dlg_layers;} {}
  decl {orb_about *m_dlg_about;} {}
  decl {orb_dlg_settings *m_dlg_settings;} {}
  decl {std::vector<orb_layer*> m_layers;} {}
  Function {orb_ui()} {} {
    Fl_Window m_window {
      label florb
      private xywh {597 207 600 450} type Double align 80 resizable visible
    } {
      Fl_Pack {} {open
        private xywh {0 0 600 450} resizable
      } {
        Fl_Menu_Bar m_menubar {
          private xywh {0 0 600 25}
        } {
          Submenu {} {
            label File
            private xywh {0 0 100 20}
          } {
            MenuItem m_menu_file_close {
              label Quit
              private xywh {0 0 100 20}
            }
          }
          Submenu {} {
            label Edit open
            private xywh {0 0 100 20}
          } {
            MenuItem m_menu_edit_settings {
              label Settings
              private xywh {0 0 100 20}
            }
            MenuItem m_menu_edit_layers {
              label Layers
              private xywh {0 0 100 20}
            }
          }
          Submenu {} {
            label Help open
            private xywh {0 0 100 20}
          } {
            MenuItem m_menu_help_about {
              label About
              private xywh {0 0 100 20}
            }
          }
        }
        Fl_Box m_mapctrl {
          label {Slippy Map}
          private xywh {0 25 600 400} resizable
          class orb_mapctrl
        }
        Fl_Pack {} {open
          private xywh {0 425 600 25} type HORIZONTAL
        } {
          Fl_Box {} {
            private xywh {0 425 35 25} box FLAT_BOX color 94
          }
          Fl_Value_Output m_out_lon {
            label lon
            private xywh {35 425 120 25} box FLAT_BOX color 94 align 100
          }
          Fl_Box {} {
            private xywh {155 425 35 25} box FLAT_BOX color 94
          }
          Fl_Value_Output m_out_lat {
            label lat
            private xywh {190 425 120 25} box FLAT_BOX color 94
          }
          Fl_Box {} {
            private xywh {310 425 35 25} box FLAT_BOX color 94
          }
          Fl_Value_Output m_out_zoom {
            label z
            private xywh {345 425 120 25} box FLAT_BOX color 94
          }
          Fl_Box {} {
            private xywh {465 425 85 25} box FLAT_BOX color 94 resizable
          }
          Fl_Pack {} {open
            xywh {465 425 240 25} type HORIZONTAL
          } {
            Fl_Button m_btn_minus {
              label {-}
              user_data this
              callback cb_btn_minus
              private xywh {575 425 25 25}
            }
            Fl_Button m_btn_plus {
              label {+}
              user_data this
              callback cb_btn_plus
              private xywh {550 425 25 25}
            }
          }
        }
      }
    }
    code {// Create UI dialogs
m_dlg_about = new orb_about();
m_dlg_layers = new orb_layers();
m_dlg_settings = new orb_dlg_settings();

// Register UI callbacks
m_window->callback(cb_close, this);
m_menu_help_about->callback(cb_menu, this);
m_menu_file_close->callback(cb_menu, this);
m_menu_edit_layers->callback(cb_menu, this);
m_menu_edit_settings->callback(cb_menu, this);
m_mapctrl->callback(cb_mapctrl, this);

// Create the OSM base layer
orb_layer *l = new orb_osmlayer();
l->callback(cb_layer, this);
m_layers.push_back(l);

// Set the OSM base layer
m_mapctrl->layers(m_layers);} {}
  }
  Function {~orb_ui()} {} {
    code {// Delete UI dialogs
delete(m_dlg_about);
delete(m_dlg_layers);
delete(m_dlg_settings);

// Delete toplevel window
delete(m_window);

// Delete all the layers
for (std::vector<orb_layer*>::iterator iter=m_layers.begin();iter!=m_layers.end();++iter)
    delete *iter;

std::cout << "Goodbye" << std::endl;} {}
  }
  Function {show(int argc, char *argv[])} {return_type void
  } {
    code {m_window->show(argc, argv);} {}
  }
  Function {updateinfo()} {open private return_type void
  } {
    code {orb_point<double> pos;
unsigned int z = 0;
m_mapctrl->mousegps(pos);
m_mapctrl->zoom_get(z);

std::stringstream ss(std::stringstream::out);
ss.precision(8);

ss << pos.get_x();
m_out_lon->value(pos.get_x());

ss.clear();
ss << pos.get_y();
m_out_lat->value(pos.get_y());

ss.clear();
ss << z;
m_out_zoom->value(z);} {}
  }
  Function {updatelayers(std::vector<orb_layer*> &layers)} {private return_type int
  } {
    code {// Update the map control with the updated set of layers
m_mapctrl->layers(layers);

// Check whether any existing layer has beed deleted
for (std::vector<orb_layer*>::iterator itold=m_layers.begin();itold!=m_layers.end();++itold) {
    
    // Try to find the current layer in the updated list
    std::vector<orb_layer*>::iterator itnew=layers.begin();
    for (;itnew!=layers.end();++itnew)
    	if (*itold == *itnew)
    	    break;
    
    // Layer not found in the updated list, delete it.
    if (itnew == layers.end())
    	delete *itold;
}

// Update the callbacks (for any new layers which don't have one registered yet)
for (std::vector<orb_layer*>::iterator itnew=layers.begin();itnew!=layers.end();++itnew)
    (*itnew)->callback(cb_layer, this);

// Update the current layers store
m_layers = layers;

return 0;} {}
  }
  Function {cb_close(Fl_Widget *widget, void *userdata)} {private return_type {static void}
  } {
    code {reinterpret_cast<orb_ui*>(userdata)->m_window->hide();} {}
  }
  Function {cb_menu(Fl_Widget *widget, void *userdata)} {private return_type {static void}
  } {
    code {orb_ui *ui = reinterpret_cast<orb_ui*>(userdata);

char picked[80];
ui->m_menubar->item_pathname(picked, sizeof(picked)-1);

if (strcmp(picked, "File/Quit") == 0) {
    ui->m_window->hide();
}
else if (strcmp(picked, "Help/About") == 0) { 
    ui->m_dlg_about->show();
}
else if (strcmp(picked, "Edit/Layers") == 0) {
    // Show the layers editor dialog
    int rc = ui->m_dlg_layers->show(ui->m_layers);
    if (rc != 0)
       return;
       
    // Update the current set of layers with the modified one
    ui->updatelayers(ui->m_dlg_layers->layers());
}
else if (strcmp(picked, "Edit/Settings") == 0) {
    ui->m_dlg_settings->show();
}

ui->m_mapctrl->refresh();} {}
  }
  Function {cb_mapctrl(Fl_Widget *widget, void *userdata)} {private return_type {static void}
  } {
    code {reinterpret_cast<orb_ui*>(userdata)->updateinfo();} {}
  }
  Function {cb_layer(void *userdata)} {private return_type {static void}
  } {
    code {reinterpret_cast<orb_ui*>(userdata)->m_mapctrl->refresh();} {}
  }
  Function {cb_btn_minus(Fl_Widget *widget, void *userdata)} {private return_type {static void}
  } {
    code {orb_ui *ui = reinterpret_cast<orb_ui*>(userdata);

unsigned int z;
ui->m_mapctrl->zoom_get(z);
if (z == 0)
    return;

ui->m_mapctrl->zoom_set(z-1);} {}
  }
  Function {cb_btn_plus(Fl_Widget *widget, void *userdata)} {private return_type {static void}
  } {
    code {orb_ui *ui = reinterpret_cast<orb_ui*>(userdata);

unsigned int z;
ui->m_mapctrl->zoom_get(z);
ui->m_mapctrl->zoom_set(z+1);} {}
  }
} 

Function {} {open
} {
  code {Fl::lock();
orb_ui ui;
ui.show(argc, argv);} {}
} 
