# data file for the Fltk User Interface Designer (fluid)
version 1.0110 
header_name {.h} 
code_name {.cxx}
decl {\#include <iostream>} {global
} 

decl {\#include <FL/Fl_File_Chooser.H>} {global
} 

decl {\#include "orb_mapctrl.hpp"} {public global
} 

decl {\#include "orb_layer.hpp"} {public global
} 

decl {\#include "orb_gpxlayer.hpp"} {global
} 

class orb_layers {open
} {
  decl {std::vector<orb_layer*> m_layers;} {}
  Function {orb_layers()} {} {
    Fl_Window m_window {
      label {Edit layers} open
      private xywh {619 252 500 297} type Double resizable modal visible
    } {
      Fl_Pack {} {open
        xywh {0 0 500 297} resizable
      } {
        Fl_Box {} {
          xywh {0 0 500 5}
        }
        Fl_Pack {} {open
          xywh {0 5 500 250} type HORIZONTAL resizable
        } {
          Fl_Box {} {
            xywh {0 5 5 250}
          }
          Fl_Browser m_browser {
            user_data this
            callback cb_browser
            private xywh {5 5 380 250} resizable
            code0 {m_browser->type(FL_HOLD_BROWSER);}
          }
          Fl_Box {} {
            xywh {385 5 5 250}
          }
          Fl_Pack {} {open
            xywh {390 5 105 250}
          } {
            Fl_Button m_btn_up {
              label Up
              user_data this
              callback cb_btn_up
              private xywh {390 5 105 25}
            }
            Fl_Button m_btn_down {
              label Down
              user_data this
              callback cb_btn_down
              private xywh {390 30 105 25}
            }
            Fl_Button m_btn_delete {
              label Delete
              user_data this
              callback cb_btn_delete
              private xywh {390 55 105 25}
            }
            Fl_Button m_btn_new {
              label New
              user_data this
              callback cb_btn_new
              private xywh {390 80 105 25}
            }
          }
          Fl_Box {} {
            xywh {495 5 5 250}
          }
        }
        Fl_Box {} {
          xywh {0 255 500 5}
        }
        Fl_Pack {} {
          xywh {0 260 500 2} type HORIZONTAL
        } {
          Fl_Box {} {
            xywh {0 260 5 2}
          }
          Fl_Box {} {
            xywh {5 260 490 2} box ENGRAVED_BOX resizable
          }
          Fl_Box {} {
            xywh {495 260 5 2}
          }
        }
        Fl_Box {} {
          xywh {0 262 500 5}
        }
        Fl_Pack {} {open
          xywh {0 267 500 25} type HORIZONTAL
        } {
          Fl_Box {} {
            private xywh {0 267 280 25} resizable
          }
          Fl_Button m_btn_cancel {
            label Abbrechen
            private xywh {280 267 105 25}
          }
          Fl_Box {} {
            private xywh {385 267 5 25}
          }
          Fl_Button m_btn_ok {
            label OK
            private xywh {390 267 105 25}
          }
          Fl_Box {} {
            private xywh {495 267 5 25}
          }
        }
        Fl_Box {} {
          xywh {0 292 500 5}
        }
      }
    }
    code {} {}
  }
  Function {~orb_layers()} {} {
    code {if (m_window)
    delete(m_window);} {}
  }
  Function {show(std::vector<orb_layer*> &layers)} {open return_type int
  } {
    code {// Store a reference to the mapctrl instance
m_layers = layers;

// Draw all the layers
refresh(0);

// Enable / disable all the correct buttons
assertui();

// Show the window
m_window->show();

int r;
for (;;) {
  Fl_Widget *o = Fl::readqueue();
  if (!o) Fl::wait();
  else if (o == m_btn_ok) {r=0;break;}
  else if (o == m_btn_cancel) {r=1;break;}
}

m_window->hide();

return r;} {}
  }
  Function {layers()} {open return_type {std::vector<orb_layer*>&}
  } {
    code {return m_layers;} {}
  }
  Function {selected()} {private return_type int
  } {
    code {int sitem = -1, nitem, nitems = m_browser->size();
for (nitem=0;nitem<nitems;nitem++) {
    if (m_browser->selected(nitem+1) > 0) {
    	sitem = nitem+1;
    	break;
    }
}

return sitem;} {}
  }
  Function {assertui()} {open private return_type int
  } {
    code {int sitem = selected();
int nitems = m_browser->size();

// No items in the browser or no item is selected disable up, down, delete
if (sitem < 0) {
    m_btn_up->deactivate();
    m_btn_down->deactivate();
    m_btn_delete->deactivate();
    return 0;    
}

// Enable all the buttons to be turned off subsequently
m_btn_up->activate();
m_btn_down->activate();
m_btn_delete->activate();

// First item, disable up
if (sitem == 1)
    m_btn_up->deactivate();
    
// Last item, disable down
if (sitem == nitems)
    m_btn_down->deactivate();

return 0;} {}
  }
  Function {refresh(int sitem)} {open private return_type int
  } {
    code {// Refresh the display
m_browser->clear();
for (std::vector<orb_layer*>::iterator iter=m_layers.begin();iter!=m_layers.end();++iter)
    m_browser->insert(1, (*iter)->name().c_str());

// Select an item if required
if (sitem > 0)  
    m_browser->value(sitem);

return 0;} {}
  }
  Function {cb_close(Fl_Widget *widget, void *userdata)} {private return_type {static void}
  } {
    code {reinterpret_cast<orb_layers*>(userdata)->m_window->hide();} {}
  }
  Function {cb_browser(Fl_Widget *widget, void *userdata)} {private return_type {static void}
  } {
    code {reinterpret_cast<orb_layers*>(userdata)->assertui();} {}
  }
  Function {cb_btn_up(Fl_Widget *widget, void *userdata)} {open private return_type {static void}
  } {
    code {orb_layers *l = reinterpret_cast<orb_layers*>(userdata);

int sitem = l->selected();
orb_layer *tmp = l->m_layers[l->m_layers.size() - sitem];
l->m_layers[l->m_layers.size() - sitem] = l->m_layers[l->m_layers.size() - sitem+1];
l->m_layers[l->m_layers.size() - sitem+1] = tmp;

l->refresh(sitem-1);
l->assertui();} {}
  }
  Function {cb_btn_down(Fl_Widget *widget, void *userdata)} {open private return_type {static void}
  } {
    code {orb_layers *l = reinterpret_cast<orb_layers*>(userdata);

int sitem = l->selected();
orb_layer *tmp = l->m_layers[l->m_layers.size() - sitem];
l->m_layers[l->m_layers.size() - sitem] = l->m_layers[l->m_layers.size() - sitem-1];
l->m_layers[l->m_layers.size() - sitem-1] = tmp;

l->refresh(sitem+1);
l->assertui();} {}
  }
  Function {cb_btn_new(Fl_Widget *widget, void *userdata)} {open private return_type {static void}
  } {
    code {orb_layers *dlg = reinterpret_cast<orb_layers*>(userdata);

// Create a file chooser instance
Fl_File_Chooser fc("/home/bjoern", "*.gpx", Fl_File_Chooser::SINGLE, "Open GPX file");
fc.preview(0);
fc.show();

// Wait for user action
while(fc.shown())
    Fl::wait();

// Do nothing on cancel
if (fc.value() == NULL)
    return;

// Try to create a new GPX layer from the file
orb_layer *l = new orb_gpxlayer(std::string(fc.value()));
dlg->m_layers.push_back(l);

// Update dialog
dlg->refresh(dlg->selected());
dlg->assertui();} {}
  }
  Function {cb_btn_delete(Fl_Widget *widget, void *userdata)} {open private return_type {static void}
  } {
    code {orb_layers *l = reinterpret_cast<orb_layers*>(userdata);

int sitem = l->selected();
l->m_layers.erase(l->m_layers.begin()+(sitem-1));

if (sitem == l->m_browser->size())
    sitem--;

l->refresh(sitem);
l->assertui();} {}
  }
} 
