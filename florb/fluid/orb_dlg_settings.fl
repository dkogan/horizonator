# data file for the Fltk User Interface Designer (fluid)
version 1.0110 
header_name {.h} 
code_name {.cxx}
decl {\#include <FL/fl_ask.H>} {global
} 

decl {\#include <vector>} {public global
} 

decl {\#include <string>} {public global
} 

decl {\#include <sstream>} {global
} 

decl {\#include "orb_settings.hpp"} {global
} 

class orb_dlg_settings {open
} {
  decl {std::string m_opt_tilecache;} {global
  }
  decl {std::string m_opt_tileserver;} {global
  }
  decl {int m_opt_trkwidth;} {global
  }
  decl {int m_opt_trkcolor;} {global
  }
  decl {unsigned int m_opt_zoommin;} {global
  }
  decl {unsigned int m_opt_zoommax;} {global
  }
  Function {orb_dlg_settings()} {open
  } {
    Fl_Window m_window {
      label {Edit settings}
      private xywh {537 173 500 297} type Double resizable modal visible
    } {
      Fl_Pack {} {open
        xywh {0 0 500 297} resizable
      } {
        Fl_Box {} {
          xywh {0 0 500 5}
        }
        Fl_Pack {} {open
          xywh {0 5 500 220} type HORIZONTAL resizable
        } {
          Fl_Box {} {
            xywh {0 5 5 220}
          }
          Fl_Browser m_browser {
            user_data this
            callback cb_browser
            private xywh {5 5 490 220} resizable
            code0 {m_browser->type(FL_HOLD_BROWSER);}
          }
          Fl_Box {} {
            xywh {495 5 5 220}
          }
        }
        Fl_Box {} {
          xywh {0 225 500 5}
        }
        Fl_Pack {} {open
          xywh {0 230 500 25} type HORIZONTAL
        } {
          Fl_Box {} {
            xywh {0 230 5 25}
          }
          Fl_Input m_value {
            private xywh {5 230 380 25} resizable
          }
          Fl_Box {} {
            xywh {385 230 5 25}
          }
          Fl_Button m_btn_update {
            label Update
            user_data this
            callback cb_btn_update
            xywh {390 230 105 25}
          }
          Fl_Box {} {
            xywh {495 230 5 25}
          }
        }
        Fl_Box {} {
          xywh {0 255 500 5}
        }
        Fl_Pack {} {
          xywh {0 260 500 2} type HORIZONTAL
        } {
          Fl_Box {} {
            xywh {0 260 5 2}
          }
          Fl_Box {} {
            xywh {5 260 490 2} box ENGRAVED_BOX resizable
          }
          Fl_Box {} {
            xywh {495 260 5 2}
          }
        }
        Fl_Box {} {
          xywh {0 262 500 5}
        }
        Fl_Pack {} {open
          xywh {0 266 500 25} type HORIZONTAL
        } {
          Fl_Box {} {
            xywh {0 267 280 25} resizable
          }
          Fl_Button m_btn_cancel {
            label Cancel
            xywh {280 267 105 25}
          }
          Fl_Box {} {
            xywh {385 267 5 25}
          }
          Fl_Button m_btn_ok {
            label OK
            xywh {390 267 105 25}
          }
          Fl_Box {} {
            xywh {495 267 5 25}
          }
        }
        Fl_Box {} {
          xywh {0 292 500 5}
        }
      }
    }
    code {} {}
  }
  Function {~orb_dlg_settings()} {} {
    code {if (m_window)
    delete(m_window);} {}
  }
  Function {show()} {open return_type int
  } {
    code {orb_settings &settings = orb_settings::get_instance();

settings.getopt(std::string("osm::tileserver"), m_opt_tileserver);
settings.getopt(std::string("osm::tilecache"), m_opt_tilecache);
settings.getopt(std::string("gpx::linecolor"), m_opt_trkcolor);
settings.getopt(std::string("gpx::linewidth"), m_opt_trkwidth);
settings.getopt(std::string("osm::zoommin"), m_opt_zoommin);
settings.getopt(std::string("osm::zoommax"), m_opt_zoommax);

refresh(-1);
assertui();

m_window->show();

int r = 0;
for (;;) {
  Fl_Widget *o = Fl::readqueue();
  if (!o) Fl::wait();
  else if (o == m_btn_ok)     {r=1;break;}
  else if (o == m_btn_cancel) {r=2;break;}
  else if (o == m_window)     {r=3;break;}
}

// OK, store settings
if (r == 1) {
    settings.setopt(std::string("osm::tileserver"), m_opt_tileserver);
    settings.setopt(std::string("osm::tilecache"), m_opt_tilecache);
    settings.setopt(std::string("gpx::linecolor"), m_opt_trkcolor);
    settings.setopt(std::string("gpx::linewidth"), m_opt_trkwidth);
    settings.setopt(std::string("osm::zoommin"), m_opt_zoommin);
    settings.setopt(std::string("osm::zoommax"), m_opt_zoommax);
    settings.serialize();
}

m_window->hide();

return r;} {}
  }
  Function {cb_close(Fl_Widget *widget, void *userdata)} {private return_type {static void}
  } {
    code {reinterpret_cast<orb_dlg_settings*>(userdata)->m_window->hide();} {}
  }
  Function {refresh(int sitem)} {open private return_type int
  } {
    code {// Clear browser and value edit
m_browser->clear();
m_value->value("");

// Fill browser
m_browser->add("Tileserver base URL");
m_browser->data(1, (void*)"osm::tileserver");
m_browser->add("Tilecache database location");
m_browser->data(2, (void*)"osm::tilecache");
m_browser->add("Track color (RGB)");
m_browser->data(3, (void*)"gpx::linecolor");
m_browser->add("Track width (pixels)");
m_browser->data(4, (void*)"gpx::linewidth");
m_browser->add("Min. zoom supported by tileserver");
m_browser->data(5, (void*)"osm::zoommin");
m_browser->add("Max. zoom supported by tileserver");
m_browser->data(6, (void*)"osm::zoommax");

// Select an item if required
if (sitem <= 0)
    return 0;	

// Fill value edit
m_browser->value(sitem);
std::string key((char*)m_browser->data(sitem));

if (key.compare("osm::tileserver") == 0) {
    m_value->value(m_opt_tileserver.c_str());
}
else if (key.compare("osm::tilecache") == 0) {
    m_value->value(m_opt_tilecache.c_str());
}
else if (key.compare("gpx::linewidth") == 0) {    
    std::ostringstream oss;
    oss << m_opt_trkwidth;

    std::string str;
    if (oss.fail())
    	str = "??";
    else
    	str = oss.str();
    
    m_value->value(str.c_str());
}
else if (key.compare("gpx::linecolor") == 0) {
    std::ostringstream oss;
    oss << "0x";
    
    oss.fill('0');
    oss.width(6);	
    oss << std::hex << m_opt_trkcolor;
    
    std::string str;
    if (oss.fail())
    	str = "??";
    else
    	str = oss.str();
    
    m_value->value(str.c_str());
}
else if (key.compare("osm::zoommin") == 0) {    
    std::ostringstream oss;
    oss << m_opt_zoommin;

    std::string str;
    if (oss.fail())
    	str = "??";
    else
    	str = oss.str();
    
    m_value->value(str.c_str());
}
else if (key.compare("osm::zoommax") == 0) {    
    std::ostringstream oss;
    oss << m_opt_zoommax;

    std::string str;
    if (oss.fail())
    	str = "??";
    else
    	str = oss.str();
    
    m_value->value(str.c_str());
}

return 0;} {selected
    }
  }
  Function {selected()} {private return_type int
  } {
    code {int sitem = -1, nitem, nitems = m_browser->size();
for (nitem=0;nitem<nitems;nitem++) {
    if (m_browser->selected(nitem+1) > 0) {
    	sitem = nitem+1;
    	break;
    }
}

return sitem;} {}
  }
  Function {assertui()} {private return_type int
  } {
    code {int sitem = selected();

if (sitem <= 0)
    m_btn_update->deactivate();
else
    m_btn_update->activate();
    
return 0;} {}
  }
  Function {cb_browser(Fl_Widget *widget, void *userdata)} {private return_type {static void}
  } {
    code {orb_dlg_settings *dlg = reinterpret_cast<orb_dlg_settings*>(userdata);

int sitem = dlg->selected();
dlg->refresh(sitem);
dlg->assertui();} {}
  }
  Function {cb_btn_update(Fl_Widget *widget, void *userdata)} {open private return_type {static void}
  } {
    code {orb_dlg_settings *dlg = reinterpret_cast<orb_dlg_settings*>(userdata);

int sitem = dlg->selected();
std::string key((char*)dlg->m_browser->data(sitem));

if (key.compare("osm::tileserver") == 0) {
    dlg->m_opt_tileserver = dlg->m_value->value();
}
else if (key.compare("osm::tilecache") == 0) {
    dlg->m_opt_tilecache = dlg->m_value->value();
}
else if (key.compare("gpx::linewidth") == 0) {
    int i;    
    std::istringstream iss(dlg->m_value->value());
    
    iss >> i;
    if (iss.fail()) {
        fl_alert("Invalid line width value.");
        return;
    }

    dlg->m_opt_trkwidth = i;
}
else if (key.compare("gpx::linecolor") == 0) {
    unsigned int i;
    std::istringstream iss(dlg->m_value->value());
    
    iss >> std::hex;
    iss >> i;
    if (iss.fail()) {
        fl_alert("Invalid color value.");
        return;
    }
        
    dlg->m_opt_trkcolor = i;        
}
else if (key.compare("osm::zoommin") == 0) {
    int i;    
    std::istringstream iss(dlg->m_value->value());
    
    iss >> i;
    if (iss.fail()) {
        fl_alert("Invalid zoom value.");
        return;
    }

    dlg->m_opt_zoommin = i;
}
else if (key.compare("osm::zoommax") == 0) {
    int i;    
    std::istringstream iss(dlg->m_value->value());
    
    iss >> i;
    if (iss.fail()) {
        fl_alert("Invalid zoom value.");
        return;
    }

    dlg->m_opt_zoommax = i;
}

dlg->refresh(sitem);
dlg->assertui();} {}
  }
} 
